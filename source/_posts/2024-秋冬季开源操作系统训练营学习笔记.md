---
title: 2024 秋冬季开源操作系统训练营学习笔记
author: Dynamic_Pigeon
avatar: https://s3.bmp.ovh/imgs/2024/10/08/ca40e9bf152dbbf0.jpg
authorLink: dynamic-pigeon.github.io
authorAbout: 一个好奇的人
authorDesc: 一个好奇的人
categories: 笔记
comments: true
date: 2024-10-08 21:07:47
updated: 2024-12-22 19:15:32
tags:
    - 2024 秋冬季开源操作系统训练营
    - Rust
    - 学习笔记
keywords:
description:
    个人学习笔记
photos: https://s3.bmp.ovh/imgs/2024/10/08/14b0416bb5096fb3.jpeg
---
个人 Rust 开源训练营学习笔记（感觉更像日记），大概会隔一段时间更新一次

## 2024-11-23

{% collapsecard  %}

~~快一个月没有更新了~~

今天又回去看了地址空间的知识。之前还是学的不扎实，昨天写阶段三的练习的时候又在想操作系统是怎么管理虚拟地址和物理地址的映射的。现在搞懂了，记录一下。

risc-v 在开启 mmu 之后所有地址访问都是虚拟地址，操作系统为了管理所有的内存，在开启 mmu 之前，需要提前建立一个虚拟地址到物理地址的映射。在 arceos 中是建立了一个零偏移的的虚拟地址到物理地址的映射（才知道地址可以被重复映射），初始化映射表之后，就可以进入 mmu 模式，之后就可以启动应用程序进入用户态了。

arceos 内核和应用用了两张页表，也就说每次 trap 的时候都需要刷一下 TLB 来保证地址访问正确。

每个进程申请内存的时候，操作系统都会从剩余物理空间中找一些空间来映射，虚拟地址的连续不代表物理地址的连续，也就是跨页的数据在物理上不一定是连续的（感觉好色）。

操作系统访问用户地址只需要找到用户的页表（前面整个内存都已经被操作系统映射了，所以操作系统可以访问所有的内存），并根据虚拟页表找到对应的物理页表，就可以直接访问（arceos 因为建立了零偏移的映射，所以不需要下一步转换，如果不是零偏移的转换需要再进行转换）。

{% endcollapsecard  %}

## 2024-10-27

{% collapsecard  %}

ch8 在 10-21 已经写完了，昨天又花了一些时间重构了一下，这个训练营无疑大大提高了我的编码能力和阅读能力。

在和群友的热烈讨论下，我也学习到了很多之前不怎么清楚的东西，但是还有很多不太懂的东西。

很期待三阶段的学习！

{% endcollapsecard  %}

## 2024-10-18

{% collapsecard  %}

***ch6 简直噩梦***

感觉写的东西问题很大，也没有完全搞懂文件系统和内存系统，就是照葫芦画瓢，我的文件系统是有严重的泄露问题的，~~但是不会改~~

今天一口气写了很多垃圾代码，然后还包括一个死锁（同志们调函数的时候一定要注意这个函数要不要持有锁）。

写好一个项目真是一门艺术。我 ch3 的代码在 ch4 ch5 ch6 分别重构了一遍，现在是我比较满意的一版。但是其他的我感觉写的就很怪，谁家结构体数据全部 pub 啊（）

最近都没有去训练，都去写 os camp 了，现在只剩下最后一个要写代码的实验了，感觉晋级在望！感觉在这个训练营学到的真的很多，本来对操作系统只是一知半解，现在经过浅层的学习，了解到了很多以前只知道名词的概念，也对操作系统的数据组织形式有了更深的了解，同时也解开了以前对汇编的疑问。以前在想为什么汇编要有操作系统作为链接，一直以为汇编是和机器绑定的，是机器码。学习了之后才知道，原来系统中断是操作系统提供的，而且寻址也是被操作系统调整过的，操作系统调度了所有程序的运行，所有程序最终都是回归到操作系统中去的。

{% endcollapsecard  %}

## 2024-10-12

{% collapsecard  %}
ch3 在昨天看了一天才看懂要干什么~~我好菜啊~~

ch3 写完后本地单独测试都能过，但是一起测试就会起飞，debug 后发现 `get_time()` 函数一直输出的是 0。群内老哥说应该是 sbi 的问题，我也不懂我也不知道啊（x

然后我就重构了一下，我然后就写了一个很~~弱智~~的代码，重现一下大概是这个感觉：

```rust
use std::cell::RefCell;

fn main() {
    let task = Task::new(1);
    println!("Task id: {}", task.get_id());
}

struct TaskInner {
    arr: [u32; 10],
    id: usize,
}

struct Task {
    inner: RefCell<TaskInner>,
}

impl Task {
    fn get_id(&self) -> u32 {
        self.inner.borrow_mut().arr[self.inner.borrow_mut().id]
    }

    fn new(id: u32) -> Task {
        Task {
            inner: RefCell::new(TaskInner {
                arr: [id; 10],
                id: 0,
            }),
        }
    }
}
```

`self.inner.borrow_mut().arr[self.inner.borrow_mut().id]` 直接借用两次直接起飞（

**警钟撅烂**

ch3 我的实现十分的垃圾，感觉性能完全不行（

ch4 直接告诉我要重写（

~~杀了我算了~~

{% endcollapsecard %}

## 2024-10-9

{% collapsecard  %}
一上来第一件事就是抛开了 rust 标准库。我应该能想到的，毕竟标准库需要依赖系统，但是 OS Camp 要开发一个系统。这下轮子都要自己造了。

~~我不会 RISV-V 汇编啊！~~

训练营用的是 Qemu7.0 模拟器模拟环境。rust 编译使用 `riscv64gc-unknown-none-elf` 编译环境

!!! note 注解
    riscv64gc-unknown-none-elf 的 CPU 架构是 riscv64gc，厂商是 unknown，操作系统是 none， elf 表示没有标准的运行时库。没有任何系统调用的封装支持，但可以生成 ELF 格式的执行程序。 我们不选择有 linux-gnu 支持的 riscv64gc-unknown-linux-gnu，是因为我们的目标是开发操作系统内核，而非在 linux 系统上运行的应用程序。

在加入编译命令 `riscv64gc-unknown-none-elf` 后再在 `main.rs` 加入 `#![no_std]` 后，如果在 vsc 使用 rust-analyzer 的时候会出现 `Can't find crete test`  的报错，但是程序又是没有问题的，这是一个 bug，官方 [issue](https://github.com/rust-lang/vscode-rust/issues/729)。

只要在 vsc 的 settings.json 加入以下内容就行了

```json
{
    "rust-analyzer.checkOnSave.allTargets": false,
    "rust-analyzer.checkOnSave.extraArgs": [
            "--target",
            "riscv64gc-unknown-none-elf"
    ]
}
```

以及训练营给出的解答：

```json
{
    // Prevent "can't find crate for `test`" error on no_std
    // Ref: https://github.com/rust-lang/vscode-rust/issues/729
    // For vscode-rust plugin users:
    "rust.target": "riscv64gc-unknown-none-elf",
    "rust.all_targets": false,
    // For Rust Analyzer plugin users:
    "rust-analyzer.cargo.target": "riscv64gc-unknown-none-elf",
    "rust-analyzer.checkOnSave.allTargets": false,
    // "rust-analyzer.cargo.features": [
    //     "board_qemu"
    // ]
}
```

实验是在裸机平台上进行的（这不是放屁吗，os 还能在哪里跑）。

看见那些中断和汇编调用，我已经要去世了

**api 与 abi 的区别**

说真的之前都不知道有 abi 这个东西。

|||
|-|-|
|API|Application Programming Interface|
|ABI| Application Binary Interface|

简单来说，ABI 就是二进制接口，来自系统底层，所有程序都可以通过遵守 ABI 来调用；API 一般局限在一个编程语言，定义了源码级别的操作。

!!! info 训练营给的解释
    **API 与 ABI 的区别**
    应用程序二进制接口 ABI 是不同二进制代码片段的连接纽带。ABI 定义了二进制机器代码级别的规则，主要包括基本数据类型、通用寄存器的使用、参数的传递规则、以及堆栈的使用等等。ABI 与处理器和内存地址等硬件架构相关，是用来约束链接器 (Linker) 和汇编器 (Assembler) 的。在同一处理器下，基于不同高级语言编写的应用程序、库和操作系统，如果遵循同样的 ABI 定义，那么它们就能正确链接和执行。
    应用程序编程接口 API 是不同源代码片段的连接纽带。API 定义了一个源码级（如 C 语言）函数的参数，参数的类型，函数的返回值等。因此 API 是用来约束编译器 (Compiler) 的：一个 API 是给编译器的一些指令，它规定了源代码可以做以及不可以做哪些事。API 与编程语言相关，如 libc 是基于 C 语言编写的标准库，那么基于 C 的应用程序就可以通过编译器建立与 libc 的联系，并能在运行中正确访问 libc 中的函数。
    [link](https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter0/2os-interface.html#apiabi)

{% endcollapsecard %}


## 2024-10-8

{% collapsecard %}
上学期第一次了解到 rust 语言。第一次听到 rust 是来自他的外号“语言神”（原神启动！），以及了解到 rust 的最大特色：**编译错误**。

学习了一段时间后，感觉 rust 是真\*\*的优雅，所有权、生命周期、借用规则让我醍醐灌顶。也让我把这套规则移动到了其他语言使用，也是大大加速了我的编写速度。

学习阶段去写了 [rustling](https://github.com/rust-lang/rustlings)、[mini-lsm](https://github.com/skyzh/mini-lsm) 开源学习项目（mini-lsm week3 开头给我干爆炸了就没有继续写下去）。

感觉还是不是很深得 rust 开发的精髓。写起来 C 里 C 气。感觉取悦编译器也是一门技术活（最经典的 rust 序列访问会生成 assert，所以可以提前 assert 减少 assert 次数）。

~~cargo 是世界上最好的包管理器！~~

感谢 [Rust语言圣经(Rust Course)](https://course.rs/about-book.html)、[Rust 程序设计语言](https://www.rustwiki.org.cn/zh-CN/book/) 和其他网络上的作者贡献的大量的学习资源。

现开源训练营一阶段晋级。（牛魔的 unsafe 链表真是依托）

~~顺便吐槽一下 C++ 那依托的 tuple~~
{% endcollapsecard %}
