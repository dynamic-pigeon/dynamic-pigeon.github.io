---
title: 记一个在群内看见的小东西
author: Dynamic_Pigeon
avatar: https://s3.bmp.ovh/imgs/2024/10/08/ca40e9bf152dbbf0.jpg
authorLink: dynamic-pigeon.github.io
authorAbout: 一个好奇的人
authorDesc: 一个好奇的人
categories: 技术
comments: true
date: 2025-05-21 16:45:20
updated: 2025-05-21 16:45:20
tags:
    - Rust
keywords:
    - Rust
    - 生命周期
description:
photos:
    - https://s3.bmp.ovh/imgs/2025/05/21/fde69d64df05b95c.png
---


在 rust 交流群看见一个人希望写一个类似 cpp mutextable 的东西，然后我叫他用 `Mutex<()>` 代替 `std::mutex` 写一下试试。

然后他反手写出类似下面的代码：

```rust
struct MutexTable {
    table: DashMap<String, Mutex<()>>,
}

impl MutexTable {
    async fn lock(&self, key: &str) -> Result<MutexGuard<'_, ()> >{
        let lock = self.table
            .entry(key.to_string())
            .or_insert_with(|| Mutex::new(()));
        let guard = lock.lock().await;
        Ok(guard)
    }
}
```

然后报错，报错信息是：

```bash
error[E0515]: cannot return value referencing local variable `lock`
  --> src/main.rs:22:9
   |
21 |         let guard = lock.lock().await;
   |                     ---- `lock` is borrowed here
22 |         Ok(guard)
   |         ^^^^^^^^^ returns a value referencing data owned by the current function
```

当时我挺纳闷的，于是我用 `HashMap` 写了一个：

```rust
struct MutexTable {
    table: HashMap<String, Mutex<()>>,
}

impl MutexTable {
    async fn lock(&mut self, key: &str) -> Result<MutexGuard<'_, ()> >{
        let mutex = self.table.entry(key.to_string()).or_insert_with(|| Mutex::new(()));
        Ok(mutex.lock().await)
    }
}
```

出乎意料的，这个编译通过了（？

----

但是我不理解啊，于是我看了一下返回值类型，`HashMap` 返回了一个 `&mut Mutex<()>` 而 `DashMap` 返回了一个 `RefMut<'_, String, Mutex<()>>`。

看不出任何东西。

进行生命周期手动标注

```rust
struct MutexTable {
    table: HashMap<String, Mutex<()>>,
}

impl MutexTable {
    async fn lock<'a>(&'a mut self, key: &str) -> Result<MutexGuard<'a, ()> >{
        let mutex: &'a mut Mutex<()> = self.table.entry(key.to_string()).or_insert_with(|| Mutex::new(()));
        Ok(mutex.lock().await)
    }
}
```

通过编译

```rust
struct MutexTable {
    table: DashMap<String, Mutex<()>>,
}

impl MutexTable {
    async fn lock<'a>(&'a self, key: &str) -> Result<MutexGuard<'a, ()> >{
        let lock: dashmap::mapref::one::RefMut<'a, String, Mutex<()>> = self.table
            .entry(key.to_string())
            .or_insert_with(|| Mutex::new(()));
        let guard: MutexGuard<'a, ()> = lock.lock().await;
        Ok(guard)
    }
}
```

报错信息：

```bash
error[E0597]: `lock` does not live long enough
  --> src/main.rs:21:41
   |
17 |     async fn lock<'a>(&'a self, key: &str) -> Result<MutexGuard<'a, ()> >{
   |                   -- lifetime `'a` defined here
18 |         let lock: dashmap::mapref::one::RefMut<'a, String, Mutex<()>> = self.table
   |             ---- binding `lock` declared here
...
21 |         let guard: MutexGuard<'a, ()> = lock.lock().await;
   |                    ------------------   ^^^^ borrowed value does not live long enough
   |                    |
   |                    type annotation requires that `lock` is borrowed for `'a`
22 |         Ok(guard)
23 |     }
   |     - `lock` dropped here while still borrowed
```

这下可以确定了，这就是因为 `RefMut` 包了一层的缘故，因为 `RefMut` 不等同与引用，所以生命周期推导规则不同，导致了不能返回